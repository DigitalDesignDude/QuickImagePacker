<!DOCTYPE html>
<html lang="en">

<head>
    <!--STANDARD META TAGS-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="BlFlpxQYGdtVzN8Uv22-6tgt8hyg7Pf2b1p-rpqrXSc" />
    <title>Quick Image Packer</title>

    <!--FAVICONS-->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/png" href="/favicon.png">

    <!--INFO META TAGS -->
    <meta name="description" content="A simple web app for combining images of the same size into an image grid, sprite sheet, or texture atlas.">
    <meta name="author" content="DigitalDesignDude">
    <meta name="keywords" content="quick image packer, image packer, packer, images, app, online, generator, spritesheet, sprite sheet, spritesheet packer, sprite frame, texture atlas, texture packer, texture, image grid, grid, row, column, combine, crop, trim">

    <!--SOCIAL SNIPPET META TAGS-->
    <meta property="og:site_name" content="Quick Image Packer">
    <meta property="og:title" content="Quick Image Packer">
    <meta property="og:description" content="A simple web app for combining images of the same size into an image grid, sprite sheet, or texture atlas.">
    <link rel="canonical" href="https://digitaldesigndude.github.io/QuickImagePacker/">
    <meta property="og:url" content="https://digitaldesigndude.github.io/QuickImagePacker/">
    <meta property="og:image" content="https://digitaldesigndude.github.io/QuickImagePacker/images/screenshot-quick-image-packer.png">
    <meta property="og:image:width" content="1280">
    <meta property="og:image:height" content="640">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="en_US">

    <meta name="twitter:title" content="Quick Image Packer">
    <meta name="twitter:description" content="A simple web app for combining images of the same size into an image grid, sprite sheet, or texture atlas.">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://digitaldesigndude.github.io/QuickImagePacker/images/screenshot-quick-image-packer.png">

    <!--STYLING-->
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <div id="main-content" class="has-sidebar">
        <div id="menu-container">
            <div id="menu">

                <!--INTRO INFORMATION -->
                <h1><i class="icon-logo"></i> Quick Image Packer </h1>
                <p style="margin-bottom: 30px;">A simple web app for combining images of the same size into an image grid, sprite sheet, or texture atlas.</p>

                <!--CONTROLS-->
                <div style="margin-bottom: 30px;">
                    <div>
                        <input type="file" id="imageInput" accept="image/*" multiple style="margin-bottom: 10px;">
                        <button id="download-btn" class="btn-primary" style="float: right;">Download Image</button>
                    </div>
                    <h3>Image Grid Options</h3>
                    <div class="input-group">
                        <label for="rows">Rows:</label>
                        <input class="input-field" type="number" id="rows" min="1" value="10" oninput="arrangeImages()">
                    </div>
                    <div class="input-group">
                        <label for="columns">Columns:</label>
                        <input class="input-field" type="number" id="columns" min="1" value="10" oninput="arrangeImages()">
                    </div>
                    <div class="input-group">
                        <label>
                            Zig Zag Order:
                            <input type="checkbox" id="zig-toggler" oninput="arrangeImages()">
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            Add Grid Lines:
                            <input type="checkbox" id="grid-toggler" oninput="arrangeImages()">
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            Grid Line Color:
                            <input type="color" checked id="grid-color-input" value="#00FFFF" oninput="arrangeImages()">
                        </label>
                    </div>
                    <div class="input-group">
                        <label for="grid-size-input">Grid Line Size:</label>
                        <input class="input-field" type="number" id="grid-size-input" min="1" value="1" oninput="arrangeImages()">
                    </div>
                </div>

                <!--CROPPING CONTROLS-->
                <div style="margin-bottom: 30px;">
                    <h3>Cropping</h3>
                    <div class="input-group">
                        <label for="crop-top">Top:</label>
                        <input class="input-field" type="number" id="crop-top" min="0" value="0" oninput="arrangeImages()">
                    </div>
                    <div class="input-group">
                        <label for="crop-bottom">Bottom:</label>
                        <input class="input-field" type="number" id="crop-bottom" min="0" value="0" oninput="arrangeImages()">
                    </div>
                    <div class="input-group">
                        <label for="crop-left">Left:</label>
                        <input class="input-field" type="number" id="crop-left" min="0" value="0" oninput="arrangeImages()">
                    </div>
                    <div class="input-group">
                        <label for="crop-right">Right:</label>
                        <input class="input-field" type="number" id="crop-right" min="0" value="0" oninput="arrangeImages()">
                    </div>
                </div>

                <!--VIEW OPTIONS-->
                <div style="margin-bottom: 30px;">
                    <h3>View Options</h3>
                    <div class="input-group">
                        <label>
                            Allow Smoothing:
                            <input type="checkbox" checked id="smooth-toggler" oninput="toggleSmoothing()">
                        </label>
                    </div>
                    <div class="input-group">
                        <label>
                            Auto Fit to View:
                            <input type="checkbox" checked id="fit-view-toggler" oninput="toggleFitView()">
                        </label>
                    </div>
                    <div class="input-group">
                        <label for="zoomSlider">Zoom Level:</label>
                        <input type="range" id="zoom-slider" min="0.1" max="10.0" step="0.1" value="1" oninput="setCanvasZoom()">
                        <span style="float: right;" id="zoom-value">100%</span>
                    </div>
                </div>
                <div id="menu-footer">
                    Site by <a href="https://github.com/DigitalDesignDude">DigitalDesignDude</a>
                </div>
            </div>
            <div id="menu-toggler" style="content: url('images/img-arrow-left.svg');" onclick="toggleMenu()"></div>
        </div>

        <!--Image Canvas-->
        <div class="canvas-container">
            <!--COLLAPSE HEADER TOGGLER-->
            <canvas id="image-canvas" class="fit-view"></canvas>
        </div>

    </div>

    <script>
        document.getElementById('imageInput').addEventListener('change', handleFileSelect);
        document.getElementById('download-btn').addEventListener('click', downloadCombinedImage);

        //Array to Store all the images in
        let images = [];

        function handleFileSelect(event) {
            const files = event.target.files;

            if (!files || files.length === 0) {
                return;
            }

            // Reset the images array everytime images are uploaded.
            images = [];

            loadedImages = 0;

            // Sort files based on filenames using numeric option.
            const sortedFiles = Array.from(files).sort((a, b) => {
                return a.name.localeCompare(b.name, undefined, {
                    numeric: true,
                    sensitivity: 'base'
                });
            });

            images = sortedFiles.map(file => {
                const img = new Image();
                img.onload = function() {
                    loadedImages++;
                    if (loadedImages === images.length) {
                        arrangeImages();
                    }
                };
                img.src = URL.createObjectURL(file);
                return img;
            });
        }

        function arrangeImages() {

            if (images.length === 0) {
                return; // Exit the function if there are no images.
            }

            //Get References to all the Control Settings
            const rows = parseInt(document.getElementById('rows').value, 10);
            const columns = parseInt(document.getElementById('columns').value, 10);
            const cropTop = parseInt(document.getElementById('crop-top').value, 10);
            const cropBottom = parseInt(document.getElementById('crop-bottom').value, 10);
            const cropLeft = parseInt(document.getElementById('crop-left').value, 10);
            const cropRight = parseInt(document.getElementById('crop-right').value, 10);

            const imageCanvas = document.getElementById('image-canvas');
            const context = imageCanvas.getContext('2d');

            /*Grid Inputs*/
            const gridToggler = document.getElementById('grid-toggler');
            const gridColorInput = document.getElementById('grid-color-input');
            const gridSizeInput = document.getElementById('grid-size-input');

            let imageWidth = images[0].naturalWidth - cropLeft - cropRight;
            let imageHeight = images[0].naturalHeight - cropTop - cropBottom;

            // Set canvas size to fit all images based on one's actual image file dimensions
            imageCanvas.width = columns * imageWidth;
            imageCanvas.height = rows * imageHeight;

            // Draw each image onto the canvas based on the arranged layout
            let currentX = 0;
            let currentY = 0;
            let ReverseX = false;

            for (let i = 0; i < rows; i++) {

                //Reserve Row Direction if enabled
                if (ReverseX == true && document.getElementById('zig-toggler').checked) {
                    //Create images Going Left
                    for (let j = 0; j < columns; j++) {
                        const imgIndex = i * columns + j;
                        if (imgIndex < images.length) {

                            //Draw the Image to the canvas at the proper position and cropping using the draw image clipping method
                            const img = images[imgIndex];
                            let x = imageWidth * (columns - 1) - j * imageWidth;
                            let y = i * imageHeight;
                            let width = img.width - cropLeft - cropRight;
                            let height = img.height - cropTop - cropBottom;

                            context.drawImage(img,
                                cropLeft,
                                cropTop,
                                img.width - cropLeft - cropRight,
                                img.height - cropTop - cropBottom,
                                x,
                                y,
                                width,
                                height
                            );

                            // Draw Gridlines if enabled
                            if (gridToggler.checked) {
                                context.strokeStyle = gridColorInput.value;
                                context.lineWidth = gridSizeInput.value;
                                context.strokeRect(
                                    x + 0.5,
                                    y + 0.5,
                                    width - 1,
                                    height - 1
                                );
                            }


                        }
                        //Signify Reverse Direction
                        if (j == 0) {
                            ReverseX = false;
                            //console.log("Reverse false");
                        }
                    }
                } else {
                    //Create images Going Right
                    for (let j = 0; j < columns; j++) {
                        const imgIndex = i * columns + j;
                        if (imgIndex < images.length) {

                            const img = images[imgIndex];
                            let x = j * imageWidth;
                            let y = i * imageHeight;
                            let width = img.width - cropLeft - cropRight;
                            let height = img.height - cropTop - cropBottom;

                            context.drawImage(img,
                                cropLeft,
                                cropTop,
                                img.width - cropLeft - cropRight,
                                img.height - cropTop - cropBottom,
                                x,
                                y,
                                width,
                                height
                            );

                            // Draw Gridlines if enabled
                            if (gridToggler.checked) {
                                context.strokeStyle = gridColorInput.value;
                                context.lineWidth = gridSizeInput.value;
                                context.strokeRect(
                                    x + 0.5,
                                    y + 0.5,
                                    width - 1,
                                    height - 1
                                );
                            }
                        }
                        //Signify Reverse Direction
                        if (j == columns - 1) {
                            ReverseX = true;
                            //console.log("Reverse true");
                        }
                    }
                }
            }
        }

        function downloadCombinedImage() {

            // Convert canvas to data URL and create a download link
            const imageCanvas = document.getElementById('image-canvas');
            const combinedDataURL = imageCanvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.href = combinedDataURL;
            downloadLink.download = 'combined_image.png';
            downloadLink.click();
        }


        function toggleMenu() {
            document.getElementById("main-content").classList.toggle("has-sidebar");
            document.getElementById("menu-container").classList.toggle("collapse");
            document.getElementById("menu-toggler").classList.toggle("flipped");
        }

        function toggleSmoothing() {
            if (document.getElementById('smooth-toggler').checked) {
                document.getElementById("image-canvas").style.imageRendering = "auto";
            } else {
                document.getElementById("image-canvas").style.imageRendering = "pixelated";
            }
        }

        function toggleFitView() {
            if (document.getElementById('fit-view-toggler').checked) {
                document.getElementById("image-canvas").classList.add('fit-view');
            } else {
                document.getElementById("image-canvas").classList.remove('fit-view');
            }
        }

        function setCanvasZoom() {

            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValueSpan = document.getElementById('zoom-value');
            const imageCanvas = document.getElementById('image-canvas');

            let zoomValue = parseFloat(zoomSlider.value);

            //Set the width and height of the actual canvas according to the input zoom value.
            imageCanvas.style.width = `${imageCanvas.width * zoomValue}px`;
            //Update the zoom slider text with no additional decimal places. 
            zoomValueSpan.textContent = (zoomValue * 100).toFixed(0) + "%";

            //Remove Fit View class to allow the canvas to be scaled without restraint.
            document.getElementById("image-canvas").classList.remove('fit-view');
            document.getElementById('fit-view-toggler').checked = false;
        }
    </script>
</body>

</html>